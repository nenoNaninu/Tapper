<#@ template language="C#" linePragmas="false" debug="false" hostspecific="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    Dictionary<string, string> _collectionTypeMap = new()
    {
        { "Array", "any[]"},
        { "ArraySegment<int>", "number[]"},
        { "List<float>", "number[]"},
        { "LinkedList<string>", "string[]"},
        { "Queue<Guid>", "string[]"},
        { "Stack<Uri>", "string[]"},
        { "HashSet<DateTime>", "(Date | string)[]"},
        { "IEnumerable<bool>", "boolean[]"},
        { "IReadOnlyCollection<byte>", "number[]"},
        { "IReadOnlyList<object>", "any[]"},
        { "ICollection<string>", "string[]"},
        { "IList<bool>", "boolean[]"},
        { "ISet<sbyte>", "number[]"},
    };

    static string Format(string source)
    {
        return source.Replace("<", null) .Replace(">", null).Replace(",", null);
    }
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Tapper.Test
// </auto-generated>
#nullable enable
using System;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Tapper.Test.SourceTypes;
using Tapper.TypeMappers;
using Xunit;
using Xunit.Abstractions;

namespace Tapper.Tests;

public class CollectionMapTest
{
    private readonly ITestOutputHelper _output;

    public CollectionMapTest(ITestOutputHelper output)
    {
        _output = output;
    }

<# foreach(var type in _collectionTypeMap){ #>
    [Fact]
    public void Test_ClassIncludeCollectionField<#= Format(type.Key) #>()
    {
        var compilation = CompilationSingleton.Compilation;

        var options = new TranspilationOptions(
            compilation,
            SerializerOption.Json,
            NamingStyle.None,
            EnumStyle.Value,
            NewLineOption.Lf,
            2,
            false,
            true
        );

        var codeGenerator = new TypeScriptCodeGenerator(compilation, options);

        var type = typeof(ClassIncludeCollectionField<#= Format(type.Key) #>);
        var typeSymbol = compilation.GetTypeByMetadataName(type.FullName!)!;

        var writer = new CodeWriter();

        codeGenerator.AddType(typeSymbol, ref writer);

        var code = writer.ToString();
        var gt = CollectionTypeTranspilationAnswer.Dict[nameof(ClassIncludeCollectionField<#= Format(type.Key) #>)];

        _output.WriteLine(code);
        _output.WriteLine(gt);

        Assert.Equal(gt, code, ignoreLineEndingDifferences: true);
    }

<# } #>

<# foreach(var type in _collectionTypeMap){ #>
    [Fact]
    public void Test_ClassIncludeCollectionProperty<#= Format(type.Key) #>()
    {
        var compilation = CompilationSingleton.Compilation;
        
        var options = new TranspilationOptions(
            compilation,
            SerializerOption.Json,
            NamingStyle.None,
            EnumStyle.Value,
            NewLineOption.Lf,
            2,
            false,
            true
        );

        var codeGenerator = new TypeScriptCodeGenerator(compilation, options);

        var type = typeof(ClassIncludeCollectionProperty<#= Format(type.Key) #>);
        var typeSymbol = compilation.GetTypeByMetadataName(type.FullName!)!;

        var writer = new CodeWriter();

        codeGenerator.AddType(typeSymbol, ref writer);

        var code = writer.ToString();
        var gt = CollectionTypeTranspilationAnswer.Dict[nameof(ClassIncludeCollectionProperty<#= Format(type.Key) #>)];

        _output.WriteLine(code);
        _output.WriteLine(gt);

        Assert.Equal(gt, code, ignoreLineEndingDifferences: true);
    }

<# } #>
}
