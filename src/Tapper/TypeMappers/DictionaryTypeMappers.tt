<#@ template language="C#" linePragmas="false" debug="false" hostspecific="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    Type[] dictionaryTypes = new[]
    {
        typeof(Dictionary<,>),
        typeof(IDictionary<,>),
        typeof(IReadOnlyDictionary<,>),
    };
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Tapper
// </auto-generated>
#nullable enable
using System;
using Microsoft.CodeAnalysis;

namespace Tapper.TypeMappers;

<# foreach(var type in dictionaryTypes){ #>
public class <#= type.Name.Replace("`", null) #>TypeMapper : ITypeMapper
{
    public ITypeSymbol Assign { get; }

    public <#= type.Name.Replace("`", null) #>TypeMapper(Compilation compilation)
    {
        Assign = compilation.GetTypeByMetadataName("<#= type.FullName #>")!;
    }

    public string MapTo(ITypeSymbol typeSymbol, ITranspilationOptions options)
    {
        if (typeSymbol is INamedTypeSymbol namedTypeSymbol
            && namedTypeSymbol.IsGenericType
            && SymbolEqualityComparer.Default.Equals(namedTypeSymbol.ConstructedFrom, Assign))
        {
            var mapper0 = options.TypeMapperProvider.GetTypeMapper(namedTypeSymbol.TypeArguments[0]);
            var mapper1 = options.TypeMapperProvider.GetTypeMapper(namedTypeSymbol.TypeArguments[1]);

            return $"{{ [key: {mapper0.MapTo(namedTypeSymbol.TypeArguments[0], options)}]: {mapper1.MapTo(namedTypeSymbol.TypeArguments[1], options)} }}";
        }

        throw new InvalidOperationException($"<#= type.Name.Replace("`", null) #>TypeMapper is not support {typeSymbol.ToDisplayString()}.");
    }
}

<# } #>
public static class DictionaryTypeMappers
{
    public static ITypeMapper[] Create(Compilation compilation)
    {
        var mappers = new ITypeMapper[<#= dictionaryTypes.Length #>];

<# foreach(var (type, index) in dictionaryTypes.Select((x, index) => (x, index))){ #>
        mappers[<#= index #>] = new <#= type.Name.Replace("`", null) #>TypeMapper(compilation);
<# } #>
        return mappers;
    }
}
