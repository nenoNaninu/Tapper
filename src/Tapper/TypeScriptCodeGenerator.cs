using System;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace Tapper;

public class TypeScriptCodeGenerator : ICodeGenerator
{
    private readonly string _newLineString;
    private readonly INamedTypeSymbol[] _sourceTypes;
    private readonly ITranspilationOptions _transpilationOptions;
    private readonly ITypeTranslatorProvider _typeTranslatorProvider;

    [Obsolete("Use constructor with parameter ITranspilationOptions only")]
    public TypeScriptCodeGenerator(Compilation compilation, ITranspilationOptions options)
        : this(compilation.GetSourceTypes(options.ReferencedAssembliesTranspilation), options)
    {
    }

    public TypeScriptCodeGenerator(ITranspilationOptions options) : this(options.SourceTypes.ToArray(), options)
    {
    }

    private TypeScriptCodeGenerator(INamedTypeSymbol[] sourceTypes, ITranspilationOptions options)
    {
        _transpilationOptions = options;

        _sourceTypes = sourceTypes;

        _newLineString = options.NewLine.ToNewLineString();
        _typeTranslatorProvider = new TypeTranslatorProviderBuilder(options.EnumStyle).Build();
    }
    
    public void AddHeader(IGrouping<INamespaceSymbol, INamedTypeSymbol> types, ref CodeWriter writer)
    {
        writer.Append($"/* THIS (.ts) FILE IS GENERATED BY Tapper */{_newLineString}");
        writer.Append($"/* eslint-disable */{_newLineString}");
        writer.Append($"/* tslint:disable */{_newLineString}");

        var memberTypes = types
            .SelectMany(static x => x.GetPublicFieldsAndProperties().IgnoreStatic())
            .SelectMany(RoslynExtensions.GetRelevantTypesFromMemberSymbol);

        var baseTypes = types
            .Where(static x => x.BaseType is not null
                && x.BaseType.IsType
                && x.BaseType.SpecialType != SpecialType.System_Object)
            .Select(static x => x.BaseType!);

        var differentNamespaceTypes = memberTypes
            .Concat(baseTypes)
            .OfType<INamedTypeSymbol>()
            .Where(x => !SymbolEqualityComparer.Default.Equals(x.ContainingNamespace, types.Key)
                && _sourceTypes.Contains(x, SymbolEqualityComparer.Default))
            .Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default)
            .ToLookup<INamedTypeSymbol, INamespaceSymbol>(static x => x.ContainingNamespace, SymbolEqualityComparer.Default);

        foreach (var groupingType in differentNamespaceTypes)
        {
            writer.Append($"import type {{ {string.Join(", ", groupingType.Select(x => x.Name))} }} from './{groupingType.Key.ToDisplayString()}';{_newLineString}");
        }

        writer.Append(_newLineString);
    }

    public void AddType(INamedTypeSymbol typeSymbol, ref CodeWriter writer)
    {
        var typeTranslator = _typeTranslatorProvider.GetTypeTranslator(typeSymbol);

        typeTranslator.Translate(ref writer, typeSymbol, _transpilationOptions);
    }
}
